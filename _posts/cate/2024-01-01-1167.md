---
title:  "[ë°±ì¤€1167][ğŸŸ¡2] íŠ¸ë¦¬ì˜ ì§€ë¦„ (BFS)"

categories:
  - BaekJoon
tags:
  - [BaekJoon,Gold]

toc: true
toc_sticky: true
 
date: 2024-01-01
last_modified_at: 2024-01-01
---
## **ğŸ”’ ë‚œì´ë„**
> ğŸŸ¡ ê³¨ë“œ 2   
  
  
  
## **ğŸ”’ ë¬¸ì œ**
> <https://www.acmicpc.net/problem/1167>  

![image](https://github.com/jjohmin/jjohmin.github.io/assets/128464783/14f808c1-fddf-47ca-852b-0c4563926fbb)

## ğŸ”“**ë‚´í’€ì´**
[Do-it C++ ì½”ë”©í…ŒìŠ¤íŠ¸ ì°¸ê³ ](https://www.inflearn.com/course/lecture?courseSlug=%EB%91%90%EC%9E%87-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EC%BD%94%EB%94%A9%ED%85%8C%EC%8A%A4%ED%8A%B8-%EC%94%A8%EC%81%A0%EC%81%A0&unitId=148490)  

BFS(ë„ˆë¹„ ìš°ì„  íƒìƒ‰)ë¥¼ ì´ìš©í•˜ì—¬ í•´ê²°í•˜ì˜€ë‹¤. í•˜ì§€ë§Œ ë‚œì´ë„ê°€ ë§ì´ ì–´ë ¤ì› ê³  ì •ë‹µì„ ëª‡ ë²ˆ ë³´ì•˜ë‹¤. ê·¸ë ‡ê¸°ì— ë¹„ìŠ·í•œ ìœ í˜•ì˜ ë¬¸ì œì¸ 1967 íŠ¸ë¦¬ì˜ ì§€ë¦„ ë¬¸ì œë„ í’€ê¸°ë¡œ í–ˆë‹¤.  
ì´ ë¬¸ì œì˜ í•µì‹¬ì€ ì„ì˜ì˜ ë…¸ë“œì˜ ìµœëŒ€ ê¸¸ì´ì¸ ê³³ì´ íŠ¸ë¦¬ì˜ ì§€ë¦„ ë…¸ë“œ ì¤‘ í•˜ë‚˜ë¼ëŠ” ê²ƒì´ë‹¤.  
ì´ ë¬¸ì œì—ì„œ ë‚˜ëŠ” typedefì„ í†µí•´ typeì„ ìƒˆë¡œ ì§€ì •í•˜ëŠ” ê²ƒì„ ì´ìš©í•œ í’€ì´ì™€ íì™€ ê´€ë ¨ëœ í’€ì´ì—ì„œ ë§ì´ ì‹¤ìˆ˜í–ˆë‹¤.  
  
```c++
#include <iostream>
#include <vector>
#include <algorithm>
#include <queue>
using namespace std;
typedef pair<int, int> edge;                  // ë´„
static vector<vector<edge>> A;                // ë´„
static vector<bool> visited;
static vector<int> distanced;                 // ë´„
void BFS(int node);

int main() {
	int N;
	cin >> N;
	A.resize(N + 1);

	for (int i = 0; i < N; i++) {
		int s, n, m;
		cin >> s;
		while (true) {
			cin >> n;
			if (n == -1) break;
			cin >> m;
			A[s].push_back(edge(n,m));         // ë´„
		}
	}

	distanced = vector<int>(N + 1, 0);         // ë´„
	visited = vector<bool>(N + 1, false);      // ë´„

	BFS(1);
	int MAX = 1;
	for (int i = 1; i <= N; i++) {
		if (distanced[MAX] < distanced[i])
			MAX = i;
	}
	fill(distanced.begin(), distanced.end(), 0);
	fill(visited.begin(), visited.end(), false);

	BFS(MAX);
	sort(distanced.begin(), distanced.end());
	cout << distanced[N] << endl;
}

void BFS(int node) {
	queue<int> myqueue;
	myqueue.push(node);
	visited[node] = true;
	while (!myqueue.empty()) {                    // ë´„
		int num = myqueue.front();
		myqueue.pop();
		for (edge i : A[num]) {                   // ë´„
			if (!visited[i.first]) {
				visited[i.first] = true;          // ë´„
				myqueue.push(i.first);            // ë´„
				distanced[i.first] = distanced[num] + i.second;    // ë´„
			}
		}
	}
}
```